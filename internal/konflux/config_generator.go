package konflux

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func GenerateConfig(application Application) error {
	if err := os.RemoveAll(tektonDir); err != nil {
		return err
	}
	if err := os.RemoveAll(konfluxDir); err != nil {
		return err
	}
	if err := generateKonfluxConfig(application); err != nil {
		return err
	}
	if err := generateRepositoryConfig(application); err != nil {
		return err
	}

	return nil
}

func generateRepositoryConfig(application Application) error {
	log.Printf("Generating repository configuration")
	for _, repo := range application.Repositories {
		ctx := context.Background()
		var dir string
		var err error
		if dir, err = cloneAndCheckout(ctx, repo, "/tmp/konflux/"); err != nil {
			return err
		}

		if err := cleanupAutogenerated(ctx, application, dir); err != nil {
			return err
		}

		if err := generateTektonConfig(repo, dir); err != nil {
			return err
		}
		if err := generateGitHubConfig(repo, dir); err != nil {
			return err
		}

		if err := commitAndPullRequest(ctx, repo.Branch.Name, dir); err != nil {
			return err
		}

	}

	return nil

}

func generateTektonConfig(repo Repository, targetDir string) error {
	target := filepath.Join(targetDir, tektonDir)
	log.Printf("Generate tekton config in %s\n", target)
	if err := os.MkdirAll(target, 0o755); err != nil {
		return err
	}

	for _, c := range repo.Components {
		v := c.Version
		if err := generateFileFromTemplate("component-pull-request.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-pull-request.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("component-push.yaml", c, filepath.Join(target, fmt.Sprintf("%s-%s-%s-push.yaml", hyphenize(basename(repo.Name)), hyphenize(v.Version), c.Name)), repo.Application); err != nil {
			return err
		}
	}

	return nil
}

func generateGitHubConfig(repo Repository, targetDir string) error {
	target := filepath.Join(targetDir, gitHubDir)
	log.Printf("Generate github manifests in %s\n", target)
	if err := os.MkdirAll(filepath.Join(target, "workflows"), 0o755); err != nil {
		return err
	}

	filename := fmt.Sprintf("update-sources-%s.yaml", repo.Name)
	if err := generateFileFromTemplate("update-sources.yaml", repo, filepath.Join(target, "workflows", filename), repo.Application); err != nil {
		return err
	}

	return nil
}

func generateKonfluxConfig(application Application) error {
	targetDir := filepath.Join(konfluxDir, hyphenize(application.Version.Version), application.Name)

	if err := generateKonfluxApplication(application, targetDir); err != nil {
		return err
	}

	if err := generateKonfluxComponents(application, targetDir); err != nil {
		return err
	}
	
	return nil
}

func generateKonfluxApplication(application Application, targetDir string) error {
	if err := generateFileFromTemplate("application.yaml", application, filepath.Join(targetDir, "application.yaml"), application); err != nil {
		return err
	}

	return nil
}

func generateKonfluxComponents(application Application, targetDir string) error {
	log.Printf("Generate %s konflux configuration in %s\n", application.Name, targetDir)
	for _, c := range application.Components {
		if err := generateFileFromTemplate("component.yaml", c, filepath.Join(targetDir, fmt.Sprintf("component-%s%s.yaml", c.ImagePrefix, c.Name)), application); err != nil {
			return err
		}
		if err := generateFileFromTemplate("image.yaml", c, filepath.Join(targetDir, fmt.Sprintf("image-%s%s.yaml", c.ImagePrefix, c.Name)), application); err != nil {
			return err
		}
	}

	return nil
}

func cleanupAutogenerated(ctx context.Context, application Application, dir string) error {
	log.Printf("Cleaning up %s\n", dir)
	if out, err := run(ctx, dir, "grep", "-lr", "\""+autoGeneratedHeader+"\""); err != nil {
		log.Printf("Couldn't grep for autogenerated content: %s, %s", err, out)
	} else {
		for _, f := range strings.Split(string(out), "\n") {
			if f == "" {
				continue
			}
			if err := os.Remove(filepath.Join(dir, f)); err != nil {
				return fmt.Errorf("couldn't remove autogenerated file %s: %w", f, err)
			}
		}
	}
	return nil
}
